import json
import os
from abc import abstractmethod
from typing import Any, List, Tuple

import cv2
import numpy
from shapely.geometry import Polygon

from src import utils
from src.data.annotations.annotations_manager import AnnotationsManager


class ImageTemplate:
    """An image template, that can be used to generate other images.
    An instance of ImageTemplate is created by passing a configuration object

    Attributes:
        image_path              The image path relative to the data folder
        image_id                Image id to as associated in the annotations
        type                    FIXED or DYNAMIC
        segmentation            Polygon of the image annotation
        annotation_manager      Used to retrieve the image annotation
    """

    image_path: str
    image_id: str
    type: str
    segmentation: Polygon
    annotation_manager: AnnotationsManager

    def __init__(
        self,
        config: dict,
        annotations_manager: AnnotationsManager
    ) -> None:
        self.image_id = config['image_id']
        self.image_path = config['image_path']
        self.image = cv2.imread(os.path.join(utils.ROOT_PATH, self.image_path))
        self.annotation_manager = annotations_manager
        self.segmentation = self.annotation_manager.get_segmentation_polygon(
            self.image_id)

    @abstractmethod
    def generate_image(self, patch: numpy.ndarray) -> Tuple[numpy.ndarray, Polygon]:
        """
        Generate an image from this template.
        The image is generated by applying the patch to the template image. The implementation depends on the subclass

        Returns a pair: (the new image, the new image segmentation polygon)
        """


class FixedImageTemplate(ImageTemplate):
    def __init__(self, config: dict, annotations_manager: AnnotationsManager) -> None:
        super().__init__(config, annotations_manager)
        self.type = "FIXED"

    def generate_image(self, patch: numpy.ndarray) -> Tuple[numpy.ndarray, Polygon]:
        """
        Generate an image from this template.
        The image is generated by applying the patch to the template image.
        The patch is overlapped to the original segmentation polygon

        Returns a pair: (the new image, the template segmentation polygon)
        """
        generated = self.image[:]
        


class DynamicImageTemplate(ImageTemplate):
    def __init__(self, config: dict, annotations_manager: AnnotationsManager) -> None:
        super().__init__(config, annotations_manager)
        self.type = "DYNAMIC"


class ImagesTemplatesManager:
    templates_config_path: str
    templates_config: dict
    annotation_manager: AnnotationsManager
    templates: List

    def __init__(
        self,
        templates_config_path: str,
        annotation_manager: AnnotationsManager
    ) -> None:
        self.templates_config_path = templates_config_path
        self.annotation_manager = annotation_manager

        with open(self.templates_config_path, mode='r', encoding='utf-8') as file:
            self.templates_config = json.loads(file.read())

        self.templates = []
        for template_config in self.templates_config:
            # TODO: This could replaced by a factory
            template = None
            if template_config["type"] == "FIXED":
                template_class = FixedImageTemplate
            elif template_config["type"] == "DYNAMIC":
                template_class = DynamicImageTemplate

            template = template_class(template_config, annotation_manager)
            self.templates.append(template)

    def get_template_by_image_id(
        self,
        image_id: int
    ) -> ImageTemplate:
        return list(filter(lambda template: template.image_id == image_id, self.templates))[0]
