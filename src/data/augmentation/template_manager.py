import json
import os
from abc import abstractmethod
from typing import List, Tuple, Union

import cv2
import numpy as np
from shapely.geometry import Polygon

from src import utils
from src.data.annotations.annotations_manager import AnnotationsManager
from src.data.misc import sort_2d_points


class ImageTemplate:
    """An image template, that can be used to generate other images.
    An instance of ImageTemplate is created by passing a configuration object

    Attributes:
        image_path              The image path relative to the data folder
        image_id                Image id to as associated in the annotations
        type                    FIXED or DYNAMIC
        segmentation            Polygon of the image annotation
        annotation_manager      Used to retrieve the image annotation
    """

    image_path: str
    image_id: str
    type: str
    segmentation_polygons: List[Polygon]
    annotation_manager: AnnotationsManager

    def __init__(
        self,
        config: dict,
        annotations_manager: AnnotationsManager
    ) -> None:
        self.image_id = config['image_id']
        self.image_path = config['image_path']
        self.image = cv2.cvtColor(
            cv2.imread(os.path.join(utils.ROOT_PATH, self.image_path)),
            cv2.COLOR_BGR2RGB
        )
        self.annotation_manager = annotations_manager
        self.segmentation_polygons = self.annotation_manager.get_segmentation_polygons(
            self.image_id)

    @abstractmethod
    def generate_image(self, patch: np.ndarray) -> Tuple[np.ndarray, Polygon]:
        """
        Generate an image from this template.
        The image is generated by applying the patch to the template image. The implementation depends on the subclass

        Returns a pair: (the new image, the new image segmentation polygon)
        """

    def __reorder_segmentation_points__(self, points: List):
        """
        Returns points ordered in clockwise fashion
        """
        return sort_2d_points(points)


class FixedImageTemplate(ImageTemplate):
    def __init__(self, config: dict, annotations_manager: AnnotationsManager) -> None:
        super().__init__(config, annotations_manager)
        self.type = "FIXED"

    def generate_image(self, patches: List[np.ndarray]) -> Tuple[np.ndarray, List[Polygon]]:
        """
        Generate an image from this template.
        The image is generated by applying the patch to the template image.
        The patch is overlapped to the original segmentation polygon

        Returns a pair: (the new image, the template segmentation polygon)
        """

        if len(patches) != len(self.segmentation_polygons):
            raise ValueError(f"{len(self.segmentation_polygons)} patches are needed, but {len(patches)} patches were provided")

        patched_image = self.image.copy()
        
        for (patch, polygon) in zip(patches, self.segmentation_polygons):

            # Adjust the patch to match the segmentation polygon
            src_points = [
                [0, 0],
                [0, patch.shape[0]-1],
                [patch.shape[1]-1, 0],
                [patch.shape[1]-1, patch.shape[0]-1]
            ]
            src_points = np.float32(self.__reorder_segmentation_points__(src_points))

            # Remove the last point, which is == to the first to close the polygon
            dst_points = list(polygon.exterior.coords)[:-1]
            dst_points = np.float32(self.__reorder_segmentation_points__(dst_points))

            transformation_matrix = cv2.getPerspectiveTransform(
                src_points, dst_points
            )
            trans_img = cv2.warpPerspective(
                patch,
                transformation_matrix, 
                (patched_image.shape[0], patched_image.shape[1])
            )

            # Stich the patch into the image
            def int_coords(coords):
                return np.array(coords).round().astype(np.int32)

            exterior = [int_coords(polygon.exterior.coords)]

            cv2.fillPoly(patched_image, exterior, color=(0,0,0))
            patched_image = cv2.add(patched_image, trans_img)

        return (patched_image, self.segmentation_polygons)


class DynamicImageTemplate(ImageTemplate):
    def __init__(self, config: dict, annotations_manager: AnnotationsManager) -> None:
        super().__init__(config, annotations_manager)
        self.type = "DYNAMIC"


class ImagesTemplatesManager:
    templates_config_path: str
    templates_config: dict
    annotation_manager: AnnotationsManager
    templates: List

    def __init__(
        self,
        templates_config_path: str,
        annotation_manager: AnnotationsManager
    ) -> None:
        self.templates_config_path = templates_config_path
        self.annotation_manager = annotation_manager

        with open(self.templates_config_path, mode='r', encoding='utf-8') as file:
            self.templates_config = json.loads(file.read())

        self.templates = []
        for template_config in self.templates_config:
            # TODO: This could replaced by a factory
            template = None
            if template_config["type"] == "FIXED":
                template_class = FixedImageTemplate
            elif template_config["type"] == "DYNAMIC":
                template_class = DynamicImageTemplate

            template = template_class(template_config, annotation_manager)
            self.templates.append(template)

    def get_template_by_image_id(
        self,
        image_id: int
    ) -> ImageTemplate:
        return list(filter(lambda template: template.image_id == image_id, self.templates))[0]


    def get_templates(self) -> List[ImageTemplate]:
        return self.templates